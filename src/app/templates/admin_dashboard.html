{% extends "base.html" %}
{% block content %}
  {% set stats_other = stats_total - stats_paid - stats_pending - stats_confirming %}
  {% if stats_other < 0 %}
    {% set stats_other = 0 %}
  {% endif %}

  <section class="page-head">
    <div>
      <h1 class="page-title">Dashboard</h1>
      <p class="page-subtitle">Контроль инвойсов, статусов оплаты, нагрузки и качества авто-матчинга.</p>
    </div>
    <div class="actions">
      <a class="btn btn-primary" href="/admin/payments/new">Create Payment</a>
    </div>
  </section>

  <section class="stats-grid">
    <article class="stat-card">
      <div class="stat-label">Total Payments</div>
      <div class="stat-value">{{ stats_total }}</div>
      <div class="stat-note">Все инвойсы в системе</div>
    </article>
    <article class="stat-card">
      <div class="stat-label">Pending</div>
      <div class="stat-value">{{ stats_pending }}</div>
      <div class="stat-note">Ожидают перевод</div>
    </article>
    <article class="stat-card">
      <div class="stat-label">Confirming</div>
      <div class="stat-value">{{ stats_confirming }}</div>
      <div class="stat-note">Есть tx, ждут подтверждения</div>
    </article>
    <article class="stat-card">
      <div class="stat-label">Paid</div>
      <div class="stat-value">{{ stats_paid }}</div>
      <div class="stat-note">Успешно завершены</div>
    </article>
  </section>

  <section class="insights-grid">
    <article class="panel chart-card">
      <div class="panel-head compact">
        <div>
          <h2 class="panel-title">Payment Mix</h2>
          <p class="panel-subtitle">Распределение текущих статусов.</p>
        </div>
      </div>

      <div class="donut-layout">
        <div class="donut-wrap">
          <div
            id="status-donut"
            class="donut-chart"
            data-paid="{{ stats_paid }}"
            data-pending="{{ stats_pending }}"
            data-confirming="{{ stats_confirming }}"
            data-other="{{ stats_other }}"
          ></div>
          <div class="donut-center">
            <span class="donut-center-value">{{ stats_total }}</span>
            <span class="donut-center-label">Total</span>
          </div>
        </div>

        <div class="legend-list">
          <div class="legend-row">
            <span class="legend-dot paid"></span>
            <span class="legend-name">Paid</span>
            <span class="legend-value">{{ stats_paid }}</span>
          </div>
          <div class="legend-row">
            <span class="legend-dot pending"></span>
            <span class="legend-name">Pending</span>
            <span class="legend-value">{{ stats_pending }}</span>
          </div>
          <div class="legend-row">
            <span class="legend-dot confirming"></span>
            <span class="legend-name">Confirming</span>
            <span class="legend-value">{{ stats_confirming }}</span>
          </div>
          <div class="legend-row">
            <span class="legend-dot other"></span>
            <span class="legend-name">Other</span>
            <span class="legend-value">{{ stats_other }}</span>
          </div>
        </div>
      </div>
    </article>

    <article class="panel chart-card">
      <div class="panel-head compact">
        <div>
          <h2 class="panel-title">Activity Timeline</h2>
          <p class="panel-subtitle">Интерактивная динамика создания инвойсов с переключением окна времени.</p>
        </div>
        <div class="range-switch" role="tablist" aria-label="Activity time range">
          <button type="button" class="range-btn active" data-range="60m">60m</button>
          <button type="button" class="range-btn" data-range="24h">24h</button>
          <button type="button" class="range-btn" data-range="7d">7d</button>
          <button type="button" class="range-btn" data-range="30d">30d</button>
        </div>
      </div>

      <div class="line-summary">
        <div class="line-summary-item">
          <span class="line-summary-label">Текущий интервал</span>
          <span id="today-count" class="line-summary-value">0</span>
        </div>
        <div class="line-summary-item">
          <span class="line-summary-label">Всего в окне</span>
          <span id="week-count" class="line-summary-value">0</span>
        </div>
        <div class="line-summary-item">
          <span class="line-summary-label">Пик интервала</span>
          <span id="peak-count" class="line-summary-value">0</span>
        </div>
        <div class="line-summary-item">
          <span class="line-summary-label">Среднее/интервал</span>
          <span id="avg-count" class="line-summary-value">0</span>
        </div>
        <div class="line-summary-item">
          <span class="line-summary-label">Выбранный интервал</span>
          <span id="slot-count" class="line-summary-value">-</span>
        </div>
      </div>

      <div class="line-chart-shell">
        <svg id="activity-chart" class="line-chart" viewBox="0 0 420 220" data-now="{{ now.isoformat() if now else '' }}" data-created="{% for payment in chart_payments %}{{ payment.created_at.isoformat() }}{% if not loop.last %},{% endif %}{% endfor %}">
          <g class="line-grid"></g>
          <g class="line-y-labels"></g>
          <path class="line-area" d=""></path>
          <path class="line-path" d=""></path>
          <line class="line-cursor" x1="0" y1="0" x2="0" y2="0" hidden></line>
          <circle class="line-focus" cx="0" cy="0" r="5" hidden></circle>
          <g class="line-dots"></g>
        </svg>
        <div id="activity-tooltip" class="line-tooltip" hidden></div>
        <div id="activity-detail" class="line-detail">Наведите на график, чтобы увидеть точный интервал и количество запросов.</div>
        <div id="activity-labels" class="line-labels"></div>
      </div>
    </article>
  </section>

  <section class="panel metric-help">
    <div class="metric-help-grid">
      <div class="metric-help-item">
        <span class="metric-help-dot dot-ok"></span>
        <span><strong>Match Rate:</strong> насколько хорошо система сама сопоставляет входящие переводы.</span>
      </div>
      <div class="metric-help-item">
        <span class="metric-help-dot dot-warn"></span>
        <span><strong>Transfer Issues:</strong> переводы, которым нужен ручной разбор (сумма/время/конфликт).</span>
      </div>
      <div class="metric-help-item">
        <span class="metric-help-dot dot-info"></span>
        <span><strong>TPM:</strong> transfers per minute, индикатор текущей нагрузки на мониторинг.</span>
      </div>
    </div>
  </section>

  <section class="panel">
    <div class="panel-head">
      <div>
        <h2 class="panel-title">Enterprise Ops Metrics</h2>
        <p class="panel-subtitle">Финансовая и операционная аналитика по платежам и входящим переводам.</p>
      </div>
      <div>
        <span class="load-pill load-{{ enterprise.load_level }}">Load: {{ enterprise.load_level }}</span>
        <div class="subline">Updated: {{ now|dt }}</div>
      </div>
    </div>

    <div class="kpi-grid">
      <article class="kpi-card">
        <div class="kpi-label">Confirmed Volume Total</div>
        <div class="kpi-value mono">{{ enterprise.paid_volume_total }}</div>
        <div class="kpi-note">Подтвержденный оборот за все время</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Confirmed 24H</div>
        <div class="kpi-value mono">{{ enterprise.paid_volume_24h }}</div>
        <div class="kpi-note">Оплаты, перешедшие в paid за 24 часа</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Open Exposure</div>
        <div class="kpi-value mono">{{ enterprise.pending_exposure }}</div>
        <div class="kpi-note">Сумма активных pending + confirming</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Avg Settlement (min)</div>
        <div class="kpi-value">{{ enterprise.avg_settlement_minutes if enterprise.avg_settlement_minutes is not none else "-" }}</div>
        <div class="kpi-note">Среднее время закрытия инвойса</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Auto-Match Rate 24H</div>
        <div class="kpi-value">{{ enterprise.match_rate_24h ~ "%" if enterprise.match_rate_24h is not none else "-" }}</div>
        <div class="kpi-note">{{ enterprise.transfer_matched_24h }} из {{ enterprise.transfer_total_24h }} переводов matched</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Transfer Issues 24H</div>
        <div class="kpi-value">{{ enterprise.transfer_issues_24h }}</div>
        <div class="kpi-note">Проблемные кейсы, требующие ручной проверки</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Transfers Last Hour</div>
        <div class="kpi-value">{{ enterprise.transfers_last_hour }}</div>
        <div class="kpi-note">Пиковый TPM: {{ enterprise.peak_tpm }}</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Transfers 15m / 5m</div>
        <div class="kpi-value">{{ enterprise.transfers_last_15m }} / {{ enterprise.transfers_last_5m }}</div>
        <div class="kpi-note">Срез нагрузки за короткие интервалы</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Avg TPM (5m)</div>
        <div class="kpi-value">{{ enterprise.avg_tpm_5m }}</div>
        <div class="kpi-note">Среднее число переводов в минуту</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Invoices 60m</div>
        <div class="kpi-value">{{ enterprise.payments_created_60m }}</div>
        <div class="kpi-note">Новые инвойсы за последний час</div>
      </article>
      <article class="kpi-card">
        <div class="kpi-label">Stale Active Payments</div>
        <div class="kpi-value">{{ enterprise.stale_active_count }}</div>
        <div class="kpi-note">Активные инвойсы, зависшие дольше нормы</div>
      </article>
    </div>
  </section>

  <section class="panel">
    <div class="panel-head">
      <div>
        <h2 class="panel-title">Network Capacity & Balance</h2>
        <p class="panel-subtitle">Текущая нагрузка, риски и live balance по каждой сети.</p>
      </div>
    </div>

    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>Network</th>
            <th>Live Balance</th>
            <th>Active Payments</th>
            <th>Pending Volume</th>
            <th>Transfers 1H</th>
            <th>Issues 24H</th>
            <th>Load</th>
          </tr>
        </thead>
        <tbody>
          {% for row in enterprise.network_rows %}
            <tr>
              <td data-label="Network">
                <div>{{ row.title }}</div>
                <div class="subline">req conf: {{ row.required_confirmations }}</div>
              </td>
              <td data-label="Live Balance">
                {% if row.live_balance %}
                  <div class="mono">{{ row.live_balance }} {{ row.asset_symbol }}</div>
                {% else %}
                  <div class="subline">{{ row.live_balance_error }}</div>
                {% endif %}
              </td>
              <td data-label="Active Payments">{{ row.active_payments }}</td>
              <td data-label="Pending Volume" class="mono">{{ row.pending_volume }} {{ row.asset_symbol }}</td>
              <td data-label="Transfers 1H">{{ row.transfers_last_hour }}</td>
              <td data-label="Issues 24H">{{ row.issues_last_24h }}</td>
              <td data-label="Load">
                <div class="progress-rail"><span style="width: {{ row.load_percent }}%"></span></div>
                <div class="subline">{{ row.load_percent }}%</div>
              </td>
            </tr>
          {% else %}
            <tr>
              <td class="empty-cell" colspan="7">Данные по сетям отсутствуют.</td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </section>

  <section class="panel">
    <div class="panel-head">
      <div>
        <h2 class="panel-title">Payments</h2>
        <p class="panel-subtitle">Последние 100 платежей с быстрым переходом в карточку.</p>
      </div>
    </div>

    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Network</th>
            <th>Amount</th>
            <th>Status</th>
            <th>Created</th>
          </tr>
        </thead>
        <tbody>
          {% for payment in payments %}
            <tr>
              <td data-label="ID"><a class="table-link mono" href="/admin/payments/{{ payment.id }}">{{ payment.id[:8] }}</a></td>
              <td data-label="Title">{{ payment.title }}</td>
              <td data-label="Network">{{ payment.network }}</td>
              <td data-label="Amount" class="mono">{{ payment.pay_amount|amt }}</td>
              <td data-label="Status"><span class="status-pill status-{{ payment.status }}">{{ payment.status }}</span></td>
              <td data-label="Created">{{ payment.created_at|dt }}</td>
            </tr>
          {% else %}
            <tr>
              <td class="empty-cell" colspan="6">Пока платежей нет.</td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </section>

  <script>
    (function () {
      const donutNode = document.getElementById("status-donut");
      if (donutNode) {
        const paid = Number(donutNode.dataset.paid || 0);
        const pending = Number(donutNode.dataset.pending || 0);
        const confirming = Number(donutNode.dataset.confirming || 0);
        const other = Number(donutNode.dataset.other || 0);
        const total = paid + pending + confirming + other;

        if (total > 0) {
          const paidPercent = (paid / total) * 100;
          const pendingPercent = (pending / total) * 100;
          const confirmingPercent = (confirming / total) * 100;
          const paidEnd = paidPercent;
          const pendingEnd = paidEnd + pendingPercent;
          const confirmingEnd = pendingEnd + confirmingPercent;

          donutNode.style.background = "conic-gradient(" +
            "#18a26d 0% " + paidEnd + "%," +
            "#c17a00 " + paidEnd + "% " + pendingEnd + "%," +
            "#2252c9 " + pendingEnd + "% " + confirmingEnd + "%," +
            "#93a2bd " + confirmingEnd + "% 100%)";
        }
      }

      const chartNode = document.getElementById("activity-chart");
      if (!chartNode) {
        return;
      }

      const rangeButtons = Array.from(document.querySelectorAll("[data-range]"));
      const tooltipNode = document.getElementById("activity-tooltip");
      const labelsNode = document.getElementById("activity-labels");
      const detailNode = document.getElementById("activity-detail");
      const cursorNode = chartNode.querySelector(".line-cursor");
      const focusNode = chartNode.querySelector(".line-focus");
      const dotsNode = chartNode.querySelector(".line-dots");
      const todayNode = document.getElementById("today-count");
      const weekNode = document.getElementById("week-count");
      const peakNode = document.getElementById("peak-count");
      const avgNode = document.getElementById("avg-count");
      const slotNode = document.getElementById("slot-count");

      const raw = chartNode.dataset.created || "";
      const nowRaw = chartNode.dataset.now || "";
      const createdDates = raw
        .split(",")
        .map((item) => item.trim())
        .filter(Boolean)
        .map((item) => {
          const hasTimezone = item.endsWith("Z") || item.includes("+");
          return new Date(hasTimezone ? item : (item + "Z"));
        })
        .filter((date) => !Number.isNaN(date.getTime()));

      const now = nowRaw ? new Date(nowRaw) : new Date();
      const ranges = {
        "60m": { bucketMinutes: 1, bucketCount: 60 },
        "24h": { bucketMinutes: 1, bucketCount: 1440 },
        "7d": { bucketMinutes: 60, bucketCount: 168 },
        "30d": { bucketMinutes: 180, bucketCount: 240 },
      };

      let activeRange = "60m";
      let chartState = null;
      let resizeTimer = null;

      const formatXAxisLabel = (date, bucketMinutes) => {
        if (bucketMinutes < 60) {
          return date.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit", timeZone: "UTC" });
        }
        if (bucketMinutes < 1440) {
          return date.toLocaleString("en-GB", {
            day: "2-digit",
            month: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            timeZone: "UTC",
          });
        }
        return date.toLocaleDateString("en-GB", { day: "2-digit", month: "2-digit", timeZone: "UTC" });
      };

      const formatDetailLabel = (start, end, bucketMinutes) => {
        const startTime = start.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit", timeZone: "UTC" });
        const endTime = end.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit", timeZone: "UTC" });
        if (bucketMinutes < 1440) {
          const datePart = start.toLocaleDateString("en-GB", { day: "2-digit", month: "2-digit", timeZone: "UTC" });
          return datePart + " " + startTime + " - " + endTime + " UTC";
        }
        const startDay = start.toLocaleDateString("en-GB", { day: "2-digit", month: "2-digit", timeZone: "UTC" });
        const endDay = end.toLocaleDateString("en-GB", { day: "2-digit", month: "2-digit", timeZone: "UTC" });
        return startDay + " - " + endDay + " UTC";
      };

      const alignToBucket = (date, bucketMinutes) => {
        const bucketMs = bucketMinutes * 60000;
        return new Date(Math.floor(date.getTime() / bucketMs) * bucketMs);
      };

      const buildSeries = (rangeKey) => {
        const cfg = ranges[rangeKey] || ranges["60m"];
        const bucketMs = cfg.bucketMinutes * 60000;
        const endStart = alignToBucket(now, cfg.bucketMinutes);
        const coverageStart = new Date(endStart.getTime() - ((cfg.bucketCount - 1) * bucketMs));
        const coverageEnd = new Date(endStart.getTime() + bucketMs);
        const bucketStarts = Array.from({ length: cfg.bucketCount }, function (_, idx) {
          return new Date(coverageStart.getTime() + (idx * bucketMs));
        });
        const counts = Array.from({ length: cfg.bucketCount }, function () { return 0; });

        for (const ts of createdDates) {
          const time = ts.getTime();
          if (time < coverageStart.getTime() || time >= coverageEnd.getTime()) {
            continue;
          }
          const idx = Math.floor((time - coverageStart.getTime()) / bucketMs);
          if (idx >= 0 && idx < counts.length) {
            counts[idx] += 1;
          }
        }

        const labels = bucketStarts.map((bucketStart) => formatXAxisLabel(bucketStart, cfg.bucketMinutes));
        return { counts, labels, bucketStarts, bucketMs, cfg };
      };

      const stepLinePath = (points) => {
        if (!points.length) {
          return "";
        }
        let d = "M " + points[0].x + " " + points[0].y;
        for (let i = 1; i < points.length; i += 1) {
          const prev = points[i - 1];
          const current = points[i];
          d += " L " + current.x + " " + prev.y + " L " + current.x + " " + current.y;
        }
        return d;
      };

      const stepAreaPath = (points, baseY) => {
        if (!points.length) {
          return "";
        }
        let d = "M " + points[0].x + " " + baseY + " L " + points[0].x + " " + points[0].y;
        for (let i = 1; i < points.length; i += 1) {
          const prev = points[i - 1];
          const current = points[i];
          d += " L " + current.x + " " + prev.y + " L " + current.x + " " + current.y;
        }
        const last = points[points.length - 1];
        d += " L " + last.x + " " + baseY + " Z";
        return d;
      };

      const showHover = (idx, keepVisible) => {
        if (!chartState || !chartState.points.length) {
          return;
        }
        const clampedIndex = Math.max(0, Math.min(idx, chartState.points.length - 1));
        const point = chartState.points[clampedIndex];
        const count = chartState.counts[clampedIndex] || 0;
        const start = chartState.bucketStarts[clampedIndex];
        const end = new Date(start.getTime() + chartState.bucketMs);
        const detailLabel = formatDetailLabel(start, end, chartState.cfg.bucketMinutes);
        const total = chartState.total || 1;
        const share = ((count / total) * 100).toFixed(1);

        if (slotNode) {
          slotNode.textContent = String(count);
        }
        if (detailNode) {
          detailNode.textContent = detailLabel + " | requests: " + count + " | share: " + share + "%";
        }
        if (cursorNode) {
          cursorNode.setAttribute("x1", String(point.x));
          cursorNode.setAttribute("x2", String(point.x));
          cursorNode.setAttribute("y1", String(chartState.top));
          cursorNode.setAttribute("y2", String(chartState.baseY));
          cursorNode.hidden = false;
        }
        if (focusNode) {
          focusNode.setAttribute("cx", String(point.x));
          focusNode.setAttribute("cy", String(point.y));
          focusNode.hidden = false;
        }
        if (tooltipNode) {
          const chartRect = chartNode.getBoundingClientRect();
          const scaleX = chartRect.width / Math.max(1, chartState.width || 420);
          const scaleY = chartRect.height / Math.max(1, chartState.height || 220);
          tooltipNode.textContent = chartState.labels[clampedIndex] + " | " + count;
          tooltipNode.style.left = (point.x * scaleX) + "px";
          tooltipNode.style.top = ((point.y * scaleY) - 8) + "px";
          tooltipNode.hidden = false;
        }
        if (!keepVisible && dotsNode) {
          const allDots = Array.from(dotsNode.querySelectorAll("circle"));
          allDots.forEach((dot, dotIdx) => {
            dot.classList.toggle("active", dotIdx === clampedIndex);
          });
        }
      };

      const hideHover = () => {
        if (tooltipNode) {
          tooltipNode.hidden = true;
        }
        if (cursorNode) {
          cursorNode.hidden = true;
        }
        if (focusNode) {
          focusNode.hidden = true;
        }
        if (slotNode) {
          slotNode.textContent = "-";
        }
      };

      const renderSeries = (series) => {
        const counts = series.counts;
        const labels = series.labels;
        const peak = Math.max(...counts, 0);
        const total = counts.reduce((acc, value) => acc + value, 0);
        const currentBucket = counts[counts.length - 1] || 0;
        const avg = counts.length ? (total / counts.length) : 0;

        if (todayNode) {
          todayNode.textContent = String(currentBucket);
        }
        if (weekNode) {
          weekNode.textContent = String(total);
        }
        if (peakNode) {
          peakNode.textContent = String(peak);
        }
        if (avgNode) {
          avgNode.textContent = avg.toFixed(2);
        }

        const width = 420;
        const height = 220;
        const left = 34;
        const right = 10;
        const top = 14;
        const bottom = 34;
        const usableWidth = width - left - right;
        const usableHeight = height - top - bottom;
        const baseY = top + usableHeight;
        const max = Math.max(peak, 1);

        const points = counts.map((count, idx) => {
          const x = left + (idx * usableWidth) / Math.max(1, counts.length - 1);
          const y = top + usableHeight - ((count / max) * usableHeight);
          return { x, y };
        });

        const gridNode = chartNode.querySelector(".line-grid");
        const yLabelsNode = chartNode.querySelector(".line-y-labels");
        if (yLabelsNode) {
          yLabelsNode.innerHTML = "";
        }
        if (gridNode) {
          gridNode.innerHTML = "";
          const xmlns = "http://www.w3.org/2000/svg";
          for (let i = 0; i <= 4; i += 1) {
            const ratio = i / 4;
            const y = top + (usableHeight * ratio);
            const line = document.createElementNS(xmlns, "line");
            line.setAttribute("x1", String(left));
            line.setAttribute("x2", String(left + usableWidth));
            line.setAttribute("y1", String(y));
            line.setAttribute("y2", String(y));
            gridNode.appendChild(line);

            if (yLabelsNode) {
              const label = document.createElementNS(xmlns, "text");
              const value = Math.round(max - (max * ratio));
              label.setAttribute("x", String(left - 8));
              label.setAttribute("y", String(y + 4));
              label.textContent = String(value);
              yLabelsNode.appendChild(label);
            }
          }
        }

        const pathNode = chartNode.querySelector(".line-path");
        if (pathNode) {
          pathNode.setAttribute("d", stepLinePath(points));
        }

        const areaNode = chartNode.querySelector(".line-area");
        if (areaNode) {
          areaNode.setAttribute("d", stepAreaPath(points, baseY));
        }

        if (dotsNode) {
          dotsNode.innerHTML = "";
          if (points.length <= 120) {
            const xmlns = "http://www.w3.org/2000/svg";
            points.forEach((point) => {
              const dot = document.createElementNS(xmlns, "circle");
              dot.setAttribute("cx", String(point.x));
              dot.setAttribute("cy", String(point.y));
              dot.setAttribute("r", "3");
              dotsNode.appendChild(dot);
            });
          }
        }

        if (labelsNode) {
          const slots = window.innerWidth < 760 ? 5 : 10;
          const ticks = [];
          for (let i = 0; i <= slots; i += 1) {
            const idx = Math.min(labels.length - 1, Math.round((i / slots) * (labels.length - 1)));
            ticks.push("<span>" + labels[idx] + "</span>");
          }
          labelsNode.innerHTML = ticks.join("");
        }

        chartState = {
          counts,
          labels,
          bucketStarts: series.bucketStarts,
          bucketMs: series.bucketMs,
          cfg: series.cfg,
          points,
          total,
          top,
          baseY,
          width,
          height,
        };

        hideHover();
        if (points.length > 0) {
          showHover(points.length - 1, true);
        }
      };

      const indexFromPointer = (event) => {
        if (!chartState || !chartState.points.length) {
          return 0;
        }
        const rect = chartNode.getBoundingClientRect();
        if (!rect.width) {
          return chartState.points.length - 1;
        }
        const x = Math.max(0, Math.min(event.clientX - rect.left, rect.width));
        const ratio = x / rect.width;
        return Math.round(ratio * (chartState.points.length - 1));
      };

      const applyRange = (rangeKey) => {
        activeRange = ranges[rangeKey] ? rangeKey : "60m";
        for (const button of rangeButtons) {
          button.classList.toggle("active", button.dataset.range === activeRange);
        }
        renderSeries(buildSeries(activeRange));
      };

      for (const button of rangeButtons) {
        button.addEventListener("click", function () {
          applyRange(button.dataset.range || "60m");
        });
      }

      chartNode.addEventListener("mousemove", function (event) {
        showHover(indexFromPointer(event), false);
      });
      chartNode.addEventListener("mouseleave", function () {
        if (chartState && chartState.points.length) {
          showHover(chartState.points.length - 1, true);
        } else {
          hideHover();
        }
      });
      chartNode.addEventListener("touchmove", function (event) {
        const touch = event.touches && event.touches[0];
        if (!touch) {
          return;
        }
        showHover(indexFromPointer(touch), false);
      }, { passive: true });

      window.addEventListener("resize", function () {
        if (resizeTimer) {
          clearTimeout(resizeTimer);
        }
        resizeTimer = setTimeout(function () {
          if (chartState) {
            renderSeries(buildSeries(activeRange));
          }
        }, 120);
      });

      applyRange(activeRange);
    })();
  </script>
{% endblock %}
